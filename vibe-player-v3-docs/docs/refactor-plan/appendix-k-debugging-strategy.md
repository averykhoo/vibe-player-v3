[//]: # ( vibe-player-v3/docs/refactor-plan/appendix-k-debugging-strategy.md )
# Appendix K: Local Debugging & Tracing Strategy

This appendix defines the mandatory, in-code strategy for tracing operations within the application. This is a critical
tool for debugging the flow of commands and events through the decoupled, event-driven architecture.

## K.1. The Challenge: Tracing Decoupled Systems

In a traditional monolithic call stack, debugging is straightforward. In an event-driven system, the "call stack" is
intentionally broken by the event emitter to achieve decoupling. A service emits an event, and its work is done. Later,
one or more services react to that event, starting new, unrelated call stacks. This makes it difficult to answer the
simple question: "What sequence of events led to this bug?"

The solution is to create a "logical call stack" by tagging all related work with a unique identifier.

## K.2. The Solution: `traceId` and High-Resolution Timestamps

To create a traceable, logical flow for any given operation, every structured log message and event payload **must**
include two key pieces of information:

1. **`traceId` (string):** A universally unique identifier (UUID) that is generated **once** at the beginning of a
   user-initiated operation (e.g., when the user clicks "Play"). This *same* `traceId` is then passed through every
   subsequent service call, event payload, and worker message related to that single operation. This allows developers
   to filter the console logs to see the complete, isolated story of one operation.

2. **`timestamp` (number):** A high-resolution, weakly monotonic timestamp generated by `performance.now()`. This
   provides the precise, chronological ordering for events within a trace, and is not affected by changes to the
   system's wall-clock time.

## K.3. Implementation Contract

* **`traceId` Generation:**
    * The `traceId` **must** be generated using the browser's built-in `crypto.randomUUID()` function. It is secure,
      performant, and requires no external libraries.
    * A utility function, `generateTraceId`, **must** be created in `src/lib/utils/trace.ts` to wrap this call.
    * **The use of `Date.now()` or other timestamp-based methods for the `traceId` is strictly forbidden.** This is to
      prevent trace collisions from rapid events (e.g., in automated tests) which would corrupt the logs.

  ```typescript
  // src/lib/utils/trace.ts
  /**
   * Generates a standard Version 4 UUID for use as a traceId.
   * This leverages the browser's built-in, secure crypto API.
   * @returns {string} A UUID string, e.g., "f81d4fae-7dec-41d5-9159-01155ca45417".
   */
  export function generateTraceId(): string {
    return crypto.randomUUID();
  }
  ```

* **`timestamp` Generation:**
    * The `timestamp` for all log messages **must** be generated using `performance.now()`.

* **Trace Initiation & Propagation:**
    * A new `traceId` **must** be generated inside the `AudioOrchestratorService` whenever it handles a command that
      initiates a new, top-level user action (e.g., `loadNewFile`, `togglePlay`, `beginSeek`).
    * This `traceId` **must** be propagated as an argument to all subsequent service method calls and as a property in
      all event payloads and worker messages that are part of that operation's lifecycle.

## K.4. Example Log Output & Usage

This strategy results in structured, filterable logs. A developer debugging a file loading issue can simply paste the
`traceId` into the browser console's filter box.

**Example Log Object:**

```json
{
  "traceId": "f81d4fae-7dec-41d5-9159-01155ca45417",
  "timestamp": 15345.123,
  "source": "AnalysisService",
  "event": "worker:postMessage",
  "message": "Posting audio chunk to VAD worker for analysis"
}
```

**Debugging Workflow:**

1. Find one log message related to the failed operation and copy its `traceId`.
2. Paste `"f81d4fae-7dec-41d5-9159-01155ca45417"` (with quotes) into the console filter.
3. The console now shows the complete, ordered lifecycle of that single operation across the main thread and all
   workers, making it easy to spot where the failure occurred.